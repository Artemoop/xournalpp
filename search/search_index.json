{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Coding-conventions/","text":"This wiki page describes the Coding Conventions of Xournal++, if you use an IDE, you may find a formatter configuration for your IDE in development/coding-conventions folder in main repo tree. If not, you may create one and push it. File Conventions The files are structured modular in subfolders. Each class consist of two files, a .cpp and a .h file (even if C++ is used, the files are always named .h, not .hpp). If there is a small helper class (less than 100 lines of code) it may also be placed in the Parent class file. The class- and filename have no prefix, so the filename and classname are the same. File encoding is always UTF-8, without BOM. To prevent including header files twice, each one should contain as first code line #pragma once All current compilers support this construct. This is the modern equivalent of #ifndef MY_FILE_H #define MY_FILE_H // some code #endif Code formatting Use clang-format Currently we are using version 9. Check your usual installation options first then see the download area at https://llvm.org/ (note the Ubuntu Apt and Win sections). Developers tend to use the automatic format functions of their IDE's, those aren't configured the same way other developers configured theirs, and they even differ between your own workstations. Instead of letting the developers configure their format function, we provide a clang-format configuration file. Clang-format is mostly IDE and platform independent, it is also supported by mostly every IDE. This will reduce merge conflicts due different formatting. We also don't accept PR's if the format of your changed files is wrong, so before a pull request, clang-format must be used. We provide the .clang-format property file in the project root. Clang-format is a platform and IDE independent tool from the LLVM Compiler Infrastructure project. For further information take a look at https://clang.llvm.org/docs/ClangFormat.html You can quickly reformat all your changed lines with: git-clang-format-9 Commit_name_or_Hash , make sure, your changes are staged and not committed. Example: git-clang-format-9 HEAD~6 will reformat only the changes made in the last 6 commits. Note: You may need to specify the git-clang binary ( or link git-clang-8 to git-clang) Indentation Spaces are used for indentation, indentation is 4 spaces. Each if, for, while etc. are followed by curly braces, even if it only contains one line of code (because this is a common case for errors, e.g. search for \"Apple goto fail bug\") if, for, while etc. are followed by a space, after the braced there is no space, e.g. if (a != b) { doSomething() } return needs no braces, e.g. return a; return a != b; not return (a); return (a != b); Line width is 120 chars. The 80 char limit was historical for printing, printing is usually not used any more, and 120 Chars is even on small notebooks or tables readable, so it should be a good compromise. Declare only one variable at once, don't do something like int* x, y (x is a pointer, y not) Write the * of pointer to the type, e.g. int* x , not int *x Documentation Use doxygen / javadoc compatible documentation tags, e.g. /** * Documentation of i */ int i; Add a space after // on single line comments, e.g. // This is a comment Includes Includes should be sorted. General idea is that they should be sorted alphabetically in some groups (from the top): - for cpp files corresponding h header - std libraries - external libraries (such as boost, glib, poppler, gtk) - from other dirs absolute paths / Xournal++ utils - local headers (from the same dir) If there's long list, these groups should be divided with empty line: #include \"Control.h\" #include <ctime> ... #include <utility> #include <boost/filesystem.hpp> #include <boost/locale.hpp> #include <gio/gio.h> #include <glib/gstdio.h> #include <gtk/gtk.h> #include \"gui/TextEditor.h\" #include \"gui/XournalView.h\" ... #include \"gui/toolbarMenubar/model/ToolbarData.h\" #include \"gui/toolbarMenubar/model/ToolbarModel.h\" #include \"jobs/AutosaveJob.h\" #include \"jobs/BlockingJob.h\" ... #include \"util/cpp14memory.h\" #include \"view/DocumentView.h\" #include \"view/TextView.h\" #include \"xojfile/LoadHandler.h\" #include \"CrashHandler.h\" #include \"FullscreenHandler.h\" #include \"LatexController.h\" ... #include \"UndoRedoController.h\" #include \"Util.h\" #include \"XojMsgBox.h\" #include \"config-dev.h\" #include \"config-features.h\" #include \"config.h\" #include \"i18n.h\" namespace fs = boost::filesystem; using namespace std; Namespaces using directives and declarations like using namespace ns_name and using ns_name::name are undesirable in headers. Same for namespace alias definitions. Header header Every header should start with general info comment: /* * Xournal++ * * [Header description] * * @author Xournal++ Team * https://github.com/xournalpp/xournalpp * * @license GNU GPLv2 or later */ Naming Conventions General Names are CamelCase (namespaces, classes, structs, enums, etc.) Members are camelBack Functions are camelBack No underlines are used Use short concise names - as short as possible as long as necessary E.g. do not use unknown abbreviations like int lnWidth , which is not clear without context, but int lineWidth is clear. Common short names should be used, e.g. int dpi is Ok, because it is well known. Classes, structs and namespaces shall not contain prefixes or suffixes, and are written CamelCase, starting with a uppercase letter Members and Functions shall not contain prefixes or suffixes, and are written camelBack, starting with a lowercase letter Overload operators Please don't use overload operators to extensive. Overload \"==\", \"=\" etc. are OK and usual. But don't do unexpected things. TODO Comments Try to avoid unclear TODO comments, e.g. // TODO streams is really unclear. Always write your name or the name of the relevant persons behind the todo, eg. // Todo (John Doe, Fred Doe) ... If there is a TODO which really should be done write a sentence or two what should be done why. Open an issue for Todo's. Common mistakes, please avoid them Initialize all members All constructors should initialize all members, even if not all are used. Initialize them in the body. Use lambdas or inline/constexpr functions to initialize post evaluated variables. Memory Avoid to allocate objects on the heap, especially if they are only used locally. Using the heap is almost slower than using the stack you also don't need to be aware of memory leaks. Only use the heap for big objects, objects with a dynamic size or if you have to expand the lifetime of an object. Always try to expand the lifetime with \"auto const&\" or \"auto&&\" in combination with copy elision first. Use RAII containers to manage memory in newly written code like std::unique_ptr or std::shared_ptr . Note: be very careful with pointers to objects from C library dependencies. For example, GLib/GTK implements its own reference counting mechanism and may not be compatible with STL smart pointers. Additionally, a object from a C library may require specific new/destroy method pairs for allocation and deallocation (e.g. cairo_surface_create / cairo_surface_destroy ). For such objects, you will need to implement a custom deleter in order to use a STL smart pointer. Don't use new or delete anymore, because humans make mistakes and forget to delete their objects. You'll also always get an memory leak, if a unexpected exception isn't catched in this scope. Since dtor's are always called after leaving a scope, RAII memory container will call delete in his dtor even if an exception is thrown. Examples: Wrong: { auto* ptr = new MySmalHelperObj(); myFunMayThrow(); //Memory leak & no call to ~MySmalHelperObj(); /*...*/ delete ptr; // Explicit call of ~MySmalHelperObj(); } Right & ok: { auto helper_ptr = std::make_unique<MySmalHelperObj>(); //local Stack Object myFunMayThrow(); /*...*/ } // Implicit call of ~std::unique_ptr<MySmalHelperObj>(); Right but better: { auto helper = MySmalHelperObj(); //local Stack Object myFunMayThrow(); //No memory leak; /*...*/ } // Implicit call of ~MySmalHelperObj(); Wrong: { MyObj* getMyObject(){ auto* ptr = new MyObj(); ptr->initMayThrow(); //memory leak return ptr; } Right & OK: { std::unique_ptr<MyObj> getMyObject(){ //Additionally shows owner change auto ptr = std::make_unique<MyObj>(); ptr->initMayThrow(); //no memory leak return ptr; // no move at an exception, automatic dtor call } Right but better: { MyObj getMyObject(){ auto myobj = MyObj(); myobj.initMayThrow(); //no memory leak, simple stack unwinding return myobj; // fast because of copy elision (no copy) } int main() { MyObj const& myobj1 = getMyObject(); // Life time extension of temporary, legal, same as: MyObj const myobj2 = getMyObject(); // Copy elision, MyObj&& myobj3 = getMyObject(); // Non const lifetime extension of temporary, in this case same as: MyObj myobj3 = getMyObject(); // Copy elision, very fast } Set pointer to nullptr after delete Since calling delete on a nullptr is valid, but calling it at a previously deleted pointer is undefined behaviour you should set the pointer to nullptr . Not doing this makes the search for errors difficult, because the application doesn't have to crash. if (this->timer) { delete this->timer; May call ctor twice -> undefined } To avoid this, set the pointer to nullptr : delete this->timer; this->timer = NULL; Using auto everywhere While the auto type of C++ is very handy, developers tend to abuse it. C++ is a strongly typed language and hence by using this type the developer instructs the compiler to determine the type of the variable at compilation time. This does not directly lead to problems, as the compiler is able to know about the correct type of the variable. The problems come along the way. Refactoring parts of the code may lead to bugs that occur in positions that should normally not be influenced by the changes. There may also occur bugs that fly by the compiler and won't even raise a warning but still cause problems during execution of the code. To avoid these problems do only use the auto type when creating new objects using the following statement: auto pointer = new Object();","title":"Coding conventions"},{"location":"Coding-conventions/#file-conventions","text":"The files are structured modular in subfolders. Each class consist of two files, a .cpp and a .h file (even if C++ is used, the files are always named .h, not .hpp). If there is a small helper class (less than 100 lines of code) it may also be placed in the Parent class file. The class- and filename have no prefix, so the filename and classname are the same. File encoding is always UTF-8, without BOM. To prevent including header files twice, each one should contain as first code line #pragma once All current compilers support this construct. This is the modern equivalent of #ifndef MY_FILE_H #define MY_FILE_H // some code #endif","title":"File Conventions"},{"location":"Coding-conventions/#code-formatting","text":"","title":"Code formatting"},{"location":"Coding-conventions/#use-clang-format","text":"Currently we are using version 9. Check your usual installation options first then see the download area at https://llvm.org/ (note the Ubuntu Apt and Win sections). Developers tend to use the automatic format functions of their IDE's, those aren't configured the same way other developers configured theirs, and they even differ between your own workstations. Instead of letting the developers configure their format function, we provide a clang-format configuration file. Clang-format is mostly IDE and platform independent, it is also supported by mostly every IDE. This will reduce merge conflicts due different formatting. We also don't accept PR's if the format of your changed files is wrong, so before a pull request, clang-format must be used. We provide the .clang-format property file in the project root. Clang-format is a platform and IDE independent tool from the LLVM Compiler Infrastructure project. For further information take a look at https://clang.llvm.org/docs/ClangFormat.html You can quickly reformat all your changed lines with: git-clang-format-9 Commit_name_or_Hash , make sure, your changes are staged and not committed. Example: git-clang-format-9 HEAD~6 will reformat only the changes made in the last 6 commits. Note: You may need to specify the git-clang binary ( or link git-clang-8 to git-clang)","title":"Use clang-format"},{"location":"Coding-conventions/#indentation","text":"Spaces are used for indentation, indentation is 4 spaces. Each if, for, while etc. are followed by curly braces, even if it only contains one line of code (because this is a common case for errors, e.g. search for \"Apple goto fail bug\") if, for, while etc. are followed by a space, after the braced there is no space, e.g. if (a != b) { doSomething() } return needs no braces, e.g. return a; return a != b; not return (a); return (a != b); Line width is 120 chars. The 80 char limit was historical for printing, printing is usually not used any more, and 120 Chars is even on small notebooks or tables readable, so it should be a good compromise. Declare only one variable at once, don't do something like int* x, y (x is a pointer, y not) Write the * of pointer to the type, e.g. int* x , not int *x","title":"Indentation"},{"location":"Coding-conventions/#documentation","text":"Use doxygen / javadoc compatible documentation tags, e.g. /** * Documentation of i */ int i; Add a space after // on single line comments, e.g. // This is a comment","title":"Documentation"},{"location":"Coding-conventions/#includes","text":"Includes should be sorted. General idea is that they should be sorted alphabetically in some groups (from the top): - for cpp files corresponding h header - std libraries - external libraries (such as boost, glib, poppler, gtk) - from other dirs absolute paths / Xournal++ utils - local headers (from the same dir) If there's long list, these groups should be divided with empty line: #include \"Control.h\" #include <ctime> ... #include <utility> #include <boost/filesystem.hpp> #include <boost/locale.hpp> #include <gio/gio.h> #include <glib/gstdio.h> #include <gtk/gtk.h> #include \"gui/TextEditor.h\" #include \"gui/XournalView.h\" ... #include \"gui/toolbarMenubar/model/ToolbarData.h\" #include \"gui/toolbarMenubar/model/ToolbarModel.h\" #include \"jobs/AutosaveJob.h\" #include \"jobs/BlockingJob.h\" ... #include \"util/cpp14memory.h\" #include \"view/DocumentView.h\" #include \"view/TextView.h\" #include \"xojfile/LoadHandler.h\" #include \"CrashHandler.h\" #include \"FullscreenHandler.h\" #include \"LatexController.h\" ... #include \"UndoRedoController.h\" #include \"Util.h\" #include \"XojMsgBox.h\" #include \"config-dev.h\" #include \"config-features.h\" #include \"config.h\" #include \"i18n.h\" namespace fs = boost::filesystem; using namespace std;","title":"Includes"},{"location":"Coding-conventions/#namespaces","text":"using directives and declarations like using namespace ns_name and using ns_name::name are undesirable in headers. Same for namespace alias definitions.","title":"Namespaces"},{"location":"Coding-conventions/#header-header","text":"Every header should start with general info comment: /* * Xournal++ * * [Header description] * * @author Xournal++ Team * https://github.com/xournalpp/xournalpp * * @license GNU GPLv2 or later */","title":"Header header"},{"location":"Coding-conventions/#naming-conventions","text":"","title":"Naming Conventions"},{"location":"Coding-conventions/#general","text":"Names are CamelCase (namespaces, classes, structs, enums, etc.) Members are camelBack Functions are camelBack No underlines are used Use short concise names - as short as possible as long as necessary E.g. do not use unknown abbreviations like int lnWidth , which is not clear without context, but int lineWidth is clear. Common short names should be used, e.g. int dpi is Ok, because it is well known.","title":"General"},{"location":"Coding-conventions/#classes-structs-and-namespaces","text":"shall not contain prefixes or suffixes, and are written CamelCase, starting with a uppercase letter","title":"Classes, structs and namespaces"},{"location":"Coding-conventions/#members-and-functions","text":"shall not contain prefixes or suffixes, and are written camelBack, starting with a lowercase letter","title":"Members and Functions"},{"location":"Coding-conventions/#overload-operators","text":"Please don't use overload operators to extensive. Overload \"==\", \"=\" etc. are OK and usual. But don't do unexpected things.","title":"Overload operators"},{"location":"Coding-conventions/#todo-comments","text":"Try to avoid unclear TODO comments, e.g. // TODO streams is really unclear. Always write your name or the name of the relevant persons behind the todo, eg. // Todo (John Doe, Fred Doe) ... If there is a TODO which really should be done write a sentence or two what should be done why. Open an issue for Todo's.","title":"TODO Comments"},{"location":"Coding-conventions/#common-mistakes-please-avoid-them","text":"","title":"Common mistakes, please avoid them"},{"location":"Coding-conventions/#initialize-all-members","text":"All constructors should initialize all members, even if not all are used. Initialize them in the body. Use lambdas or inline/constexpr functions to initialize post evaluated variables.","title":"Initialize all members"},{"location":"Coding-conventions/#memory","text":"","title":"Memory"},{"location":"Coding-conventions/#avoid-to-allocate-objects-on-the-heap-especially-if-they-are-only-used-locally","text":"Using the heap is almost slower than using the stack you also don't need to be aware of memory leaks. Only use the heap for big objects, objects with a dynamic size or if you have to expand the lifetime of an object.","title":"Avoid to allocate objects on the heap, especially if they are only used locally."},{"location":"Coding-conventions/#always-try-to-expand-the-lifetime-with-auto-const-or-auto-in-combination-with-copy-elision-first","text":"","title":"Always try to expand the lifetime with \"auto const&amp;\" or \"auto&amp;&amp;\" in combination with copy elision first."},{"location":"Coding-conventions/#use-raii-containers-to-manage-memory-in-newly-written-code-like-stdunique_ptr-or-stdshared_ptr","text":"Note: be very careful with pointers to objects from C library dependencies. For example, GLib/GTK implements its own reference counting mechanism and may not be compatible with STL smart pointers. Additionally, a object from a C library may require specific new/destroy method pairs for allocation and deallocation (e.g. cairo_surface_create / cairo_surface_destroy ). For such objects, you will need to implement a custom deleter in order to use a STL smart pointer.","title":"Use RAII containers to manage memory in newly written code like std::unique_ptr or std::shared_ptr."},{"location":"Coding-conventions/#dont-use-new-or-delete-anymore-because-humans-make-mistakes-and-forget-to-delete-their-objects","text":"You'll also always get an memory leak, if a unexpected exception isn't catched in this scope. Since dtor's are always called after leaving a scope, RAII memory container will call delete in his dtor even if an exception is thrown. Examples: Wrong: { auto* ptr = new MySmalHelperObj(); myFunMayThrow(); //Memory leak & no call to ~MySmalHelperObj(); /*...*/ delete ptr; // Explicit call of ~MySmalHelperObj(); } Right & ok: { auto helper_ptr = std::make_unique<MySmalHelperObj>(); //local Stack Object myFunMayThrow(); /*...*/ } // Implicit call of ~std::unique_ptr<MySmalHelperObj>(); Right but better: { auto helper = MySmalHelperObj(); //local Stack Object myFunMayThrow(); //No memory leak; /*...*/ } // Implicit call of ~MySmalHelperObj(); Wrong: { MyObj* getMyObject(){ auto* ptr = new MyObj(); ptr->initMayThrow(); //memory leak return ptr; } Right & OK: { std::unique_ptr<MyObj> getMyObject(){ //Additionally shows owner change auto ptr = std::make_unique<MyObj>(); ptr->initMayThrow(); //no memory leak return ptr; // no move at an exception, automatic dtor call } Right but better: { MyObj getMyObject(){ auto myobj = MyObj(); myobj.initMayThrow(); //no memory leak, simple stack unwinding return myobj; // fast because of copy elision (no copy) } int main() { MyObj const& myobj1 = getMyObject(); // Life time extension of temporary, legal, same as: MyObj const myobj2 = getMyObject(); // Copy elision, MyObj&& myobj3 = getMyObject(); // Non const lifetime extension of temporary, in this case same as: MyObj myobj3 = getMyObject(); // Copy elision, very fast }","title":"Don't use new or delete anymore, because humans make mistakes and forget to delete their objects."},{"location":"Coding-conventions/#set-pointer-to-nullptr-after-delete","text":"Since calling delete on a nullptr is valid, but calling it at a previously deleted pointer is undefined behaviour you should set the pointer to nullptr . Not doing this makes the search for errors difficult, because the application doesn't have to crash. if (this->timer) { delete this->timer; May call ctor twice -> undefined } To avoid this, set the pointer to nullptr : delete this->timer; this->timer = NULL;","title":"Set pointer to nullptr after delete"},{"location":"Coding-conventions/#using-auto-everywhere","text":"While the auto type of C++ is very handy, developers tend to abuse it. C++ is a strongly typed language and hence by using this type the developer instructs the compiler to determine the type of the variable at compilation time. This does not directly lead to problems, as the compiler is able to know about the correct type of the variable. The problems come along the way. Refactoring parts of the code may lead to bugs that occur in positions that should normally not be influenced by the changes. There may also occur bugs that fly by the compiler and won't even raise a warning but still cause problems during execution of the code. To avoid these problems do only use the auto type when creating new objects using the following statement: auto pointer = new Object();","title":"Using auto everywhere"},{"location":"Frequently-Asked-Questions-%26-Problem-Solving/","text":"Autosaves Where are autosaves located? There are two possible places. If you were working on an already-existing file, it should be in the same folder as the file, with the same name but ~ added to the end (example: foo.xopp is autosaved as foo.xopp~ . Otherwise, the autosave will be located in ~/.xournalpp/autosave . Crashes Why is Xournal++ crashing on Kubuntu when I open a file dialog? Try installing gnome-icon-theme . See this issue for more information. Files and icons Why aren't thumbnails appearing? If you are using the Nautilus file manager, you may be a victim of a bug in Nautilus . Common Problems and how to solve them / workarounds Multi Monitor Systems My multi monitor system on Xorg does not map my Touch and Pen Pointer to the correct position. Xournalpp draws with an offset when second monitor is connected. Try to map your pointer devices to the Monitor xournalpp is working on: # get the display name with: xrandr --query # get the pointer devices with: xinput list # map the pointer devices to the display with: xinput map-to-output <device_id> <display_name> On my Windows machine connecting to an WQHD monitor causes Xournalpp to draw on a wrong position. This is a known issue: #1801 , #1773 This seems to caused by a custom zoom factor set in the windows display settings. Try to set both monitors to the same scaling. We know, this is only a workaround and we work on a solution.","title":"Frequently Asked Questions & Problem Solving"},{"location":"Frequently-Asked-Questions-%26-Problem-Solving/#autosaves","text":"","title":"Autosaves"},{"location":"Frequently-Asked-Questions-%26-Problem-Solving/#where-are-autosaves-located","text":"There are two possible places. If you were working on an already-existing file, it should be in the same folder as the file, with the same name but ~ added to the end (example: foo.xopp is autosaved as foo.xopp~ . Otherwise, the autosave will be located in ~/.xournalpp/autosave .","title":"Where are autosaves located?"},{"location":"Frequently-Asked-Questions-%26-Problem-Solving/#crashes","text":"","title":"Crashes"},{"location":"Frequently-Asked-Questions-%26-Problem-Solving/#why-is-xournal-crashing-on-kubuntu-when-i-open-a-file-dialog","text":"Try installing gnome-icon-theme . See this issue for more information.","title":"Why is Xournal++ crashing on Kubuntu when I open a file dialog?"},{"location":"Frequently-Asked-Questions-%26-Problem-Solving/#files-and-icons","text":"","title":"Files and icons"},{"location":"Frequently-Asked-Questions-%26-Problem-Solving/#why-arent-thumbnails-appearing","text":"If you are using the Nautilus file manager, you may be a victim of a bug in Nautilus .","title":"Why aren't thumbnails appearing?"},{"location":"Frequently-Asked-Questions-%26-Problem-Solving/#common-problems-and-how-to-solve-them-workarounds","text":"","title":"Common Problems and how to solve them / workarounds"},{"location":"Frequently-Asked-Questions-%26-Problem-Solving/#multi-monitor-systems","text":"","title":"Multi Monitor Systems"},{"location":"Frequently-Asked-Questions-%26-Problem-Solving/#my-multi-monitor-system-on-xorg-does-not-map-my-touch-and-pen-pointer-to-the-correct-position-xournalpp-draws-with-an-offset-when-second-monitor-is-connected","text":"Try to map your pointer devices to the Monitor xournalpp is working on: # get the display name with: xrandr --query # get the pointer devices with: xinput list # map the pointer devices to the display with: xinput map-to-output <device_id> <display_name>","title":"My multi monitor system on Xorg does not map my Touch and Pen Pointer to the correct position.   Xournalpp draws with an offset when second monitor is connected."},{"location":"Frequently-Asked-Questions-%26-Problem-Solving/#on-my-windows-machine-connecting-to-an-wqhd-monitor-causes-xournalpp-to-draw-on-a-wrong-position","text":"This is a known issue: #1801 , #1773 This seems to caused by a custom zoom factor set in the windows display settings. Try to set both monitors to the same scaling. We know, this is only a workaround and we work on a solution.","title":"On my Windows machine connecting to an WQHD monitor causes Xournalpp to draw on a wrong position."},{"location":"Git-Diff-Filter-for-Xournal/","text":"The git diff filter allows you to track changes to .xoj files through git. Note that this still causes git to store .xoj files as binary blobs, but it allows git diff to track changes to the file. Simply create the bash script below as git_diff_xournal.sh, and edit the relevant config and .gitattributes files as follows. #!/bin/bash #This is supposed to print out a gzip file just as if it were anything else #Written by Wilson Brenna #To use, add the following to .git/config or ~/.gitconfig: # [diff \"xoj\"] # binary = true # textconv = /path/to/script/git_diff_xournal.sh # # # and add the xoj files to the .gitattributes # file at the root of a git working copy: # # *.xoj diff=xoj # #first test if the file is gzipped. output=`file ${1} | grep -c 'gzip'` if [ $output -eq \"1\" ] then gunzip -c ${1} else #our file is not gzipped cat ${1} fi","title":"Git Diff Filter for Xournal"},{"location":"Home/","text":"Welcome to the xournalpp wiki! User Manual We currently have a work-in-progress User Manual . Any contributions to the manual are welcome! There is also an FAQ that you may want to see if you have an issue. Compilation and Installation See the generic Installation instructions for building from source. Consult the files in the readme folder for platform-specific build instructions. Screenshots","title":"Home"},{"location":"Home/#user-manual","text":"We currently have a work-in-progress User Manual . Any contributions to the manual are welcome! There is also an FAQ that you may want to see if you have an issue.","title":"User Manual"},{"location":"Home/#compilation-and-installation","text":"See the generic Installation instructions for building from source. Consult the files in the readme folder for platform-specific build instructions.","title":"Compilation and Installation"},{"location":"Home/#screenshots","text":"","title":"Screenshots"},{"location":"How-to-provide-debug-info-for-input-related-bugs/","text":"Please follow these steps to provide information required to solve input related bugs: Clone the source code (with the appropriate repo/branch, if needed): git clone https://github.com/xournalpp/xournalpp cd xournalpp mkdir build && cd build (Re)Generate build files with the input debug flags unset: cmake -UDEBUG_INPUT_GDK_PRINT_EVENTS -UDEBUG_INPUT .. Build Xournal++ with the following command: cmake -DDEBUG_INPUT=ON .. cmake --build . Run Xournal++ from the console (!) and follow the steps to reproduce the error (Try to do as few steps as possible) ./src/xournalpp > debug_input.log 2>&1 Build Xournal++ once again with the following command: cmake -DDEBUG_INPUT_GDK_PRINT_EVENTS=ON .. cmake --build . Run Xournal++ from the console (!) and follow the steps to reproduce the error (Try to do as few steps as possible) ./src/xournalpp > debug_gdk_input.log 2>&1 Unset the debug flags (you may want to compile again afterwards if you don't want to see the debug output): cmake -UDEBUG_INPUT_GDK_PRINT_EVENTS -UDEBUG_INPUT .. Attach the files debug_input.log and debug_gdk_input.log , found in your current working directory, to the bug report Attach the output of the command xinput list if you use X.org (respectively libinput list-devices if you use Wayland)","title":"How to provide debug info for input related bugs"},{"location":"Installing/","text":"Installing from source In general it's probably the most frequent way you'll install Xournal++, as there are pretty much no recent packages in repositories. First of all you should clone this repository: git clone https://github.com/xournalpp/xournalpp.git cd xournalpp Dependencies readme/LinuxBuild.md and other files try to document the dependencies: please update these files if you can. CMake Xournal++ is built using CMake. Here is the process of building with CMake: Create the build directory \u2013 this is where all of the build files will be placed. bash mkdir build cd build You can generate the basic configuration with bash cmake .. If this is failing on Ubuntu/Debian, even with libpoppler-private-dev installed, try changing the POPPLER_INCLUDE_DIR cmake option from \"POPPLER_INCLUDE_DIR-NOTFOUND\" to \"/usr/include/poppler\" . This is easy to do with cmake-gui as below. This will cause install commands (see step 4) to install /usr folders by default (requires root). You can install to a local directory such as ~/.local by setting cmake .. -DCMAKE_INSTALL_PREFIX=$HOME/.local If you'd like to customize Xournal++ configuration you can tinker with cmake -D parameter, but it's much more convenient to execute bash cmake-gui .. Here you can configure all aspects of Xournal++ build. There are few configuration categories (grouping can be activated with Grouped checkbox): - ENABLE \u2013 basic stable features support - UNSTABLE \u2013 unstable, in development features - DEV \u2013 development options, which in most cases should be leaved as they are - TEST \u2013 optional features of CppUnit tests - BUILD \u2013 build dependency libraries and link them statically - EXT \u2013 add dependency basing on precompiled deb packages (UNIX only) - PATH \u2013 here you can specify alternative location of these binaries Some of these categories, or some single settings can be unavailable from beginning \u2013 they may depend on some other config flags (i.e., to enable entire TEST group, first of all you have to enable ENABLE_CPPUNIT ) It's worth mentioning that there are also some hidden options that are shown when Advanced is checked. However, don't modify them if you don't know what they can do, or else it will result in unexpected behavior (please don't report bugs if you've made such changes or you've been specifically asked to in a bug report). All custom options are listed in README file under cmake directory. After making all changes you should click Generate button to generate Makefiles. In the console you can see all configuration steps and at the ending some general info about used features. Now you can close cmake-gui. Now it's time for real building :) To do this you have just to execute cmake --build . in the build directory. You can also specify a specific target using cmake --build . --target <target> : - xournalpp \u2013 main executable (found in build/src dir) - xournal-thumbnailer \u2013 thumbnailer used to extract thumbnails from .xoj files (found in build/src/xoj-preview-extractor ) - xournalpp-test \u2013 CppUnit testing binary, which should be executed after any kind of source edit (found in build/test ) Other binary targets are used for internal building support: - xournalpp-core \u2013 used by xournalpp and xournalpp-test targets - util \u2013 util static library (from path src/util ) used by xournalpp and xournalpp-test targets If you have multicore processor you can build with make -jN where N is number of simultaneous jobs. To install entire package execute, you first need to compile it: bash cmake --build . Then you can install it with (if you need sudo, be careful--it may create files with root permissions in the build directory) bash cmake --build . --target install It'll install all needed files (of course without xournalpp-test ) including desktop files and translations. Building a pull request First, you need to find the URL of the repository of the PR. You can do this by going to the PR page and looking for XXX wants to merge N commits into xournalpp:master from YYY . The YYY part should have the format Username:Branchname . Then, you can checkout the PR with git clone https://github.com/Username/xournalpp -b Branchname where you will need to replace Username and Branchname with the ones you just found. Afterwards, you can compile and install Xournal++ like above.","title":"Installing from source"},{"location":"Installing/#installing-from-source","text":"In general it's probably the most frequent way you'll install Xournal++, as there are pretty much no recent packages in repositories. First of all you should clone this repository: git clone https://github.com/xournalpp/xournalpp.git cd xournalpp","title":"Installing from source"},{"location":"Installing/#dependencies","text":"readme/LinuxBuild.md and other files try to document the dependencies: please update these files if you can.","title":"Dependencies"},{"location":"Installing/#cmake","text":"Xournal++ is built using CMake. Here is the process of building with CMake: Create the build directory \u2013 this is where all of the build files will be placed. bash mkdir build cd build You can generate the basic configuration with bash cmake .. If this is failing on Ubuntu/Debian, even with libpoppler-private-dev installed, try changing the POPPLER_INCLUDE_DIR cmake option from \"POPPLER_INCLUDE_DIR-NOTFOUND\" to \"/usr/include/poppler\" . This is easy to do with cmake-gui as below. This will cause install commands (see step 4) to install /usr folders by default (requires root). You can install to a local directory such as ~/.local by setting cmake .. -DCMAKE_INSTALL_PREFIX=$HOME/.local If you'd like to customize Xournal++ configuration you can tinker with cmake -D parameter, but it's much more convenient to execute bash cmake-gui .. Here you can configure all aspects of Xournal++ build. There are few configuration categories (grouping can be activated with Grouped checkbox): - ENABLE \u2013 basic stable features support - UNSTABLE \u2013 unstable, in development features - DEV \u2013 development options, which in most cases should be leaved as they are - TEST \u2013 optional features of CppUnit tests - BUILD \u2013 build dependency libraries and link them statically - EXT \u2013 add dependency basing on precompiled deb packages (UNIX only) - PATH \u2013 here you can specify alternative location of these binaries Some of these categories, or some single settings can be unavailable from beginning \u2013 they may depend on some other config flags (i.e., to enable entire TEST group, first of all you have to enable ENABLE_CPPUNIT ) It's worth mentioning that there are also some hidden options that are shown when Advanced is checked. However, don't modify them if you don't know what they can do, or else it will result in unexpected behavior (please don't report bugs if you've made such changes or you've been specifically asked to in a bug report). All custom options are listed in README file under cmake directory. After making all changes you should click Generate button to generate Makefiles. In the console you can see all configuration steps and at the ending some general info about used features. Now you can close cmake-gui. Now it's time for real building :) To do this you have just to execute cmake --build . in the build directory. You can also specify a specific target using cmake --build . --target <target> : - xournalpp \u2013 main executable (found in build/src dir) - xournal-thumbnailer \u2013 thumbnailer used to extract thumbnails from .xoj files (found in build/src/xoj-preview-extractor ) - xournalpp-test \u2013 CppUnit testing binary, which should be executed after any kind of source edit (found in build/test ) Other binary targets are used for internal building support: - xournalpp-core \u2013 used by xournalpp and xournalpp-test targets - util \u2013 util static library (from path src/util ) used by xournalpp and xournalpp-test targets If you have multicore processor you can build with make -jN where N is number of simultaneous jobs. To install entire package execute, you first need to compile it: bash cmake --build . Then you can install it with (if you need sudo, be careful--it may create files with root permissions in the build directory) bash cmake --build . --target install It'll install all needed files (of course without xournalpp-test ) including desktop files and translations.","title":"CMake"},{"location":"Installing/#building-a-pull-request","text":"First, you need to find the URL of the repository of the PR. You can do this by going to the PR page and looking for XXX wants to merge N commits into xournalpp:master from YYY . The YYY part should have the format Username:Branchname . Then, you can checkout the PR with git clone https://github.com/Username/xournalpp -b Branchname where you will need to replace Username and Branchname with the ones you just found. Afterwards, you can compile and install Xournal++ like above.","title":"Building a pull request"},{"location":"Pen-eraser-button-issues/","text":"If your pen has a programmable button, you can map it to eraser or any other tool of your choice. However, depending on the display server you're actually using, it could happen that: pressing the button while hovering the screen engages the tool (e.g: eraser) and start erasing actually touching the screen with the pen tip while doing so, just writes instead of erasing That depends on your pen's driver settings. Suppose you've created /usr/share/X11/xorg.conf.d/30-wacom.conf configuration file for X11 If you're using \"wacom\" driver you probably want to enable TPCButton or TabletPCButton to avoid the described behaviour. Here's an example: # N-Trig Duosense Electromagnetic Digitizer Section \"InputClass\" Identifier \"Wacom N-Trig class\" MatchProduct \"HID 1b96:0001|N-Trig Pen|N-Trig DuoSense|1B96:1B05 Pen\" MatchDevicePath \"/dev/input/event*\" MatchIsTablet \"on\" Driver \"wacom\" Option \"Button2\" \"3\" Option \"TabletPCButton\" \"on\" Option \"TPCButton\" \"on\" EndSection","title":"Pen eraser button issues"},{"location":"User-Manual/","text":"This manual is a draft and a work in progress. If you have the time you can help write some paragraphs ;-) Introduction Xournal++ is a notetaking and PDF annotation tool that is based on Xournal but written from scratch in C++, using GTK3 instead of GTK2. It supports pressure sensitive pens (e.g. Wacom), text input, image input, LaTeX formula entry as well as a number of other useful features such as shape recognition and layers. Feel free to report any bugs you encounter or make feature requestss on our Issue Tracker . You're also welcome to submit pull requests . Getting Started When you first open up Xournal++, you will see a new, blank document. You can immediately start adding to the document, or you can load an existing one with the File > Open menu option. General Usage A typical Xournal++ workflow looks like the following: 1. Use the File menu to load an existing Xournal++ project, create a new document, or load a PDF file. 2. Annotate or markup the document using one of the tools in the toolbar, such as the Stroke tool, the Text tool, or the Image tool. 3. Save periodically. 4. If needed, export the document as a PDF file by selecting File > Export as PDF in the menu. Once you are ready to begin editing a document, you can draw strokes and add objects using some of the tools described below . If you need more space, you can add more pages using one of the Journal > ... options or by right clicking a page in the Page Panel (in the default layout, it is on the left side of the program). Customization Xournal++ is highly customizable and has many configurable settings. You can edit the settings by selecting Edit > Preferences from the menu. For example: * You can try enabling the optional \"Experimental Input System\" (in the Input System tab), which fixes many input-related issues and is a better experience overall. * You can customize mouse/stylus/touchscreen controls. * You can edit how Xournal++'s interface is organized in the View tab. * You can adjust zoom and layout settings. Additionally, you can also edit how Xournal++'s interace is organized (e.g. where buttons are, where the panels should be located) by selecting one of the options in View > Toolbars . The configuration files are generally located at $HOME/.xournalpp on Linux: * toolbar.ini - it's possible to create new toolbars layouts manually and precisely. * colornames.ini - in case you've added custom colors in your toolbar, you can add a label to them following this format: [custom] ff00ff=4bit Magenta ff00bb=Hot pink ff0000=4bit Red ... Note that this six-hex-digits format does not include the 0x prefix, which is actually mandatory for toolbar.ini . Example: COLOR(0xff00bb) Tools Handwriting Tools The handwriting tools allow you to write on the document using a mouse or a pressure-sensitive stylus. There are three such tools: Pen , Highlighter , and Eraser . Pen The Pen tool allows you to draw lines on the document. It supports mouse input, as well as pressure-sensitive styluses (e.g. with a graphics tablet). Highlighter Eraser The Eraser tool can remove strokes or parts of strokes. It has three modes: 1. Standard : remove parts of strokes that the cursor moves over. 2. Whiteout : paint a white stroke. 3. Delete Stroke : remove the entirety of any stroke that the cursor touches. Colors and Thickness The Pen and Highlighter tools can be used to draw strokes of different colors and thicknesses. To change the color of any selected stroke or any future strokes you draw, click on one of the color buttons (in the default layout, the color buttons are at the right side of the toolbar second from the top). Besides the preset color buttons, you can also set a custom color by clicking on the Select color button. To change the thickness, press one of the thickness buttons (in the default layout, they are to the left of the color buttons). It is also possible to automatically fill in the area enclosed by a stroke; this Fill Mode can be toggled by selecting the paint bucket icon (in the default layout, it is to the left of the color buttons). Shapes The Pen and Highlighter tool can also draw shapes instead of strokes. In the default layout, you can find the Shapes Toggle Menu to the right of the Text Tool (the big \"T\"). The Shapes Toggle Menu will have a dropdown arrow on its right. After selecting one of the shape modes in the menu, the Pen and Highlighter will place down the selected shape instead of strokes. The selectable shapes are: Draw Rectangle : Draws a rectangle. Draw Circle : Draws a circle. Draw Arrow : Draws an arrow from the initial point of contact to wherever you finish the stroke. Draw Line : Draws a line. Draw Coordinate System : Draws an \"L\" shape. Stroke Recognizer : After you finish the stroke, it will attempt to convert the stroke into one of the shape types above (it will leave the stroke as-is if it cannot). Object Tools Text The Text tool inserts text (objects) onto the document. To do so, click anywhere on the document to begin editing. Any existing text objects can be altered by clicking on them with the text tool. A text object's color and font can be customized by clicking the corresponding buttons in the toolbar. Image The Image button inserts an image onto the document. Clicking on the Image button will bring up a file dialog, which will allow you to choose which image you want to insert. An image can be repositioned or resized with one of the selection tools. LaTeX The LaTeX button inserts a LaTeX formula onto the document. Note that the LaTeX feature requires a working version of LaTeX to be installed on your computer (specifically, the feature needs to be able to call pdflatex ). In addition, LaTeX standalone package needs to be installed, which typically requires installation of texlive-latex-extra . On Ubuntu or similar Linux systems this means sudo apt-get texlive-latex-extra For other operating systems you will need to consult your LaTeX installation manual on how to add the standalone package. Clicking on the LaTeX button will bring up a dialog which will allow you to type in a formula. A preview will be displayed in the center of the dialog, which will updating as you type and indicate whether your formula is valid. Once you are done, you can click the OK button to insert the LaTeX onto the document; the rendered formula will appear at the top-left corner of the current page. The formula is now a graphical object; it can be selected, moved and scaled as desired, but in the current version of xournal++ its LaTeX code cannot be edited and modified - if you need to change something, you have to delete the object and create a new one. Selection and Movement Tools Selection Vertical Space Hand Snapping Audio Recording and Playback Go to Edit > Preferences > Audio Recording and set the Audio Folder as well as the appropriate Input Device and Output Device . If you need to edit the recording audio gain, take a look at the preferences tab mentioned above. Please test this new feature in advance before relying on it to work. It could contain undiscovered bugs specific to some hardware or software that we have not tested. Usage To record audio, first press the Start/Stop Recording button (icon: a solid red circle). Recording will begin when you create the next stroke or object and will stop when the button is pressed again. The audio playback will be attached to that object. To playback audio, use the Play Object tool and click on the object for which you recorded audio. You can pause and stop the playback of the audio with the buttons next to the recording button in the toolbar. Menu Entries File The File menu has the usual entries along with an Annotate PDF option which allows you to open a PDF and draw on top, and an Export PDF option that allows you to save your document as a PDF. Edit The Edit menu is also pretty standard, with a Find function that allows you to search in any text, as well as a Preferences dialog. View Navigation Journal The Journal menu allows you to configure settings for the document that is currently being edited. Tools Help","title":"User Manual"},{"location":"User-Manual/#introduction","text":"Xournal++ is a notetaking and PDF annotation tool that is based on Xournal but written from scratch in C++, using GTK3 instead of GTK2. It supports pressure sensitive pens (e.g. Wacom), text input, image input, LaTeX formula entry as well as a number of other useful features such as shape recognition and layers. Feel free to report any bugs you encounter or make feature requestss on our Issue Tracker . You're also welcome to submit pull requests .","title":"Introduction"},{"location":"User-Manual/#getting-started","text":"When you first open up Xournal++, you will see a new, blank document. You can immediately start adding to the document, or you can load an existing one with the File > Open menu option.","title":"Getting Started"},{"location":"User-Manual/#general-usage","text":"A typical Xournal++ workflow looks like the following: 1. Use the File menu to load an existing Xournal++ project, create a new document, or load a PDF file. 2. Annotate or markup the document using one of the tools in the toolbar, such as the Stroke tool, the Text tool, or the Image tool. 3. Save periodically. 4. If needed, export the document as a PDF file by selecting File > Export as PDF in the menu. Once you are ready to begin editing a document, you can draw strokes and add objects using some of the tools described below . If you need more space, you can add more pages using one of the Journal > ... options or by right clicking a page in the Page Panel (in the default layout, it is on the left side of the program).","title":"General Usage"},{"location":"User-Manual/#customization","text":"Xournal++ is highly customizable and has many configurable settings. You can edit the settings by selecting Edit > Preferences from the menu. For example: * You can try enabling the optional \"Experimental Input System\" (in the Input System tab), which fixes many input-related issues and is a better experience overall. * You can customize mouse/stylus/touchscreen controls. * You can edit how Xournal++'s interface is organized in the View tab. * You can adjust zoom and layout settings. Additionally, you can also edit how Xournal++'s interace is organized (e.g. where buttons are, where the panels should be located) by selecting one of the options in View > Toolbars . The configuration files are generally located at $HOME/.xournalpp on Linux: * toolbar.ini - it's possible to create new toolbars layouts manually and precisely. * colornames.ini - in case you've added custom colors in your toolbar, you can add a label to them following this format: [custom] ff00ff=4bit Magenta ff00bb=Hot pink ff0000=4bit Red ... Note that this six-hex-digits format does not include the 0x prefix, which is actually mandatory for toolbar.ini . Example: COLOR(0xff00bb)","title":"Customization"},{"location":"User-Manual/#tools","text":"","title":"Tools"},{"location":"User-Manual/#handwriting-tools","text":"The handwriting tools allow you to write on the document using a mouse or a pressure-sensitive stylus. There are three such tools: Pen , Highlighter , and Eraser .","title":"Handwriting Tools"},{"location":"User-Manual/#pen","text":"The Pen tool allows you to draw lines on the document. It supports mouse input, as well as pressure-sensitive styluses (e.g. with a graphics tablet).","title":"Pen"},{"location":"User-Manual/#highlighter","text":"","title":"Highlighter"},{"location":"User-Manual/#eraser","text":"The Eraser tool can remove strokes or parts of strokes. It has three modes: 1. Standard : remove parts of strokes that the cursor moves over. 2. Whiteout : paint a white stroke. 3. Delete Stroke : remove the entirety of any stroke that the cursor touches.","title":"Eraser"},{"location":"User-Manual/#colors-and-thickness","text":"The Pen and Highlighter tools can be used to draw strokes of different colors and thicknesses. To change the color of any selected stroke or any future strokes you draw, click on one of the color buttons (in the default layout, the color buttons are at the right side of the toolbar second from the top). Besides the preset color buttons, you can also set a custom color by clicking on the Select color button. To change the thickness, press one of the thickness buttons (in the default layout, they are to the left of the color buttons). It is also possible to automatically fill in the area enclosed by a stroke; this Fill Mode can be toggled by selecting the paint bucket icon (in the default layout, it is to the left of the color buttons).","title":"Colors and Thickness"},{"location":"User-Manual/#shapes","text":"The Pen and Highlighter tool can also draw shapes instead of strokes. In the default layout, you can find the Shapes Toggle Menu to the right of the Text Tool (the big \"T\"). The Shapes Toggle Menu will have a dropdown arrow on its right. After selecting one of the shape modes in the menu, the Pen and Highlighter will place down the selected shape instead of strokes. The selectable shapes are: Draw Rectangle : Draws a rectangle. Draw Circle : Draws a circle. Draw Arrow : Draws an arrow from the initial point of contact to wherever you finish the stroke. Draw Line : Draws a line. Draw Coordinate System : Draws an \"L\" shape. Stroke Recognizer : After you finish the stroke, it will attempt to convert the stroke into one of the shape types above (it will leave the stroke as-is if it cannot).","title":"Shapes"},{"location":"User-Manual/#object-tools","text":"","title":"Object Tools"},{"location":"User-Manual/#text","text":"The Text tool inserts text (objects) onto the document. To do so, click anywhere on the document to begin editing. Any existing text objects can be altered by clicking on them with the text tool. A text object's color and font can be customized by clicking the corresponding buttons in the toolbar.","title":"Text"},{"location":"User-Manual/#image","text":"The Image button inserts an image onto the document. Clicking on the Image button will bring up a file dialog, which will allow you to choose which image you want to insert. An image can be repositioned or resized with one of the selection tools.","title":"Image"},{"location":"User-Manual/#latex","text":"The LaTeX button inserts a LaTeX formula onto the document. Note that the LaTeX feature requires a working version of LaTeX to be installed on your computer (specifically, the feature needs to be able to call pdflatex ). In addition, LaTeX standalone package needs to be installed, which typically requires installation of texlive-latex-extra . On Ubuntu or similar Linux systems this means sudo apt-get texlive-latex-extra For other operating systems you will need to consult your LaTeX installation manual on how to add the standalone package. Clicking on the LaTeX button will bring up a dialog which will allow you to type in a formula. A preview will be displayed in the center of the dialog, which will updating as you type and indicate whether your formula is valid. Once you are done, you can click the OK button to insert the LaTeX onto the document; the rendered formula will appear at the top-left corner of the current page. The formula is now a graphical object; it can be selected, moved and scaled as desired, but in the current version of xournal++ its LaTeX code cannot be edited and modified - if you need to change something, you have to delete the object and create a new one.","title":"LaTeX"},{"location":"User-Manual/#selection-and-movement-tools","text":"","title":"Selection and Movement Tools"},{"location":"User-Manual/#selection","text":"","title":"Selection"},{"location":"User-Manual/#vertical-space","text":"","title":"Vertical Space"},{"location":"User-Manual/#hand","text":"","title":"Hand"},{"location":"User-Manual/#snapping","text":"","title":"Snapping"},{"location":"User-Manual/#audio-recording-and-playback","text":"Go to Edit > Preferences > Audio Recording and set the Audio Folder as well as the appropriate Input Device and Output Device . If you need to edit the recording audio gain, take a look at the preferences tab mentioned above. Please test this new feature in advance before relying on it to work. It could contain undiscovered bugs specific to some hardware or software that we have not tested.","title":"Audio Recording and Playback"},{"location":"User-Manual/#usage","text":"To record audio, first press the Start/Stop Recording button (icon: a solid red circle). Recording will begin when you create the next stroke or object and will stop when the button is pressed again. The audio playback will be attached to that object. To playback audio, use the Play Object tool and click on the object for which you recorded audio. You can pause and stop the playback of the audio with the buttons next to the recording button in the toolbar.","title":"Usage"},{"location":"User-Manual/#menu-entries","text":"","title":"Menu Entries"},{"location":"User-Manual/#file","text":"The File menu has the usual entries along with an Annotate PDF option which allows you to open a PDF and draw on top, and an Export PDF option that allows you to save your document as a PDF.","title":"File"},{"location":"User-Manual/#edit","text":"The Edit menu is also pretty standard, with a Find function that allows you to search in any text, as well as a Preferences dialog.","title":"Edit"},{"location":"User-Manual/#view","text":"","title":"View"},{"location":"User-Manual/#navigation","text":"","title":"Navigation"},{"location":"User-Manual/#journal","text":"The Journal menu allows you to configure settings for the document that is currently being edited.","title":"Journal"},{"location":"User-Manual/#tools_1","text":"","title":"Tools"},{"location":"User-Manual/#help","text":"","title":"Help"},{"location":"_Sidebar_Install_instructions/","text":"Build instructions Linux MacOS Windows","title":"Build instructions"},{"location":"_Sidebar_Install_instructions/#build-instructions","text":"Linux MacOS Windows","title":"Build instructions"}]}